name: Sample CI
on: [push, pull_request]

jobs:
  test-functions:
    strategy:
      matrix:
        function:
          - functions/csv-import
          - functions/log-event
          - functions/process-events
    name: Test Function - ${{ matrix.function }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'
          cache: 'pip'
      - name: Install Python dependencies
        run: pip install -r requirements.txt
        working-directory: ${{ matrix.function }}
      - name: Install HTTPie and additional dependencies for API testing
        run: |
          pip install httpie
          pip install pandas requests
        if: matrix.function == 'functions/csv-import'
      - name: Run tests if test_main.py exists
        run: |
          if [ -f "test_main.py" ]; then
            echo "Running tests with test_main.py"
            pytest
          else
            echo "No test_main.py found, skipping tests"
          fi
        working-directory: ${{ matrix.function }}
      - name: Run Python function and verify output
        run: |
          python main.py > output.log 2>&1 &
          PID=$!
          timeout=30
          elapsed=0
          while [ $elapsed -lt $timeout ]; do
            if grep -q "running at port 8081" output.log; then
              echo "‚úÖ Application started successfully"
              break
            fi
            sleep 1
            elapsed=$((elapsed+1))
          done
          
          if [ $elapsed -ge $timeout ]; then
            echo "‚ùå Application failed to start within $timeout seconds"
            echo "=== Application startup log ==="
            cat output.log
            echo "=== End of startup log ==="
            kill $PID 2>/dev/null || true
            exit 1
          fi
          
          # Track if any tests failed (but don't exit immediately)
          TEST_FAILURES=0
          
          # Run additional requests for csv-import function
          if [[ "${{ matrix.function }}" == "functions/csv-import" ]]; then
            echo "Running additional requests for csv-import function..."
          
            # Debug: Show current directory and files
            echo "=== Debug: Current directory and files ==="
            pwd
            ls -la
            echo "=== End debug info ==="
          
            # Wait a moment for the service to be fully ready
            sleep 2
          
            # Create sample CSV file if it doesn't exist
            if [ ! -f "security_events.csv" ]; then
              echo "Creating sample security_events.csv file..."
              echo "timestamp,event_type,severity,description,source_ip,destination_ip,user" > security_events.csv
              echo "2025-07-11T14:14:08Z,login_failure,medium,Failed login from IP 192.168.1.100,192.168.1.100,192.168.1.1,test.user" >> security_events.csv
              echo "2025-07-11T14:15:22Z,malware_detected,high,Malware detected on workstation,192.168.1.101,192.168.1.1,admin.user" >> security_events.csv
              echo "Sample CSV created:"
              cat security_events.csv
            else
              echo "Using existing security_events.csv:"
              cat security_events.csv
            fi
          
            # Request 1 - Import CSV with file path (with --ignore-stdin fix)
            echo "=== Making first request (import-file) ==="
          
            echo "Executing: http --ignore-stdin POST :8081 method=POST url=/import-csv 'body[csv_file_path]=security_events.csv'"
          
            # Capture both stdout and stderr, and get exit code
            set +e
            http --ignore-stdin POST :8081 method=POST url=/import-csv "body[csv_file_path]=security_events.csv" > import_file_output.log 2>&1
            IMPORT_FILE_EXIT_CODE=$?
            set -e
          
            echo "Import-file exit code: $IMPORT_FILE_EXIT_CODE"
            echo "Import-file full output:"
            cat import_file_output.log
          
            if [ $IMPORT_FILE_EXIT_CODE -eq 0 ]; then
              echo "‚úÖ Import-file HTTPie request executed successfully"
          
              # Verify response structure
              if grep -q '"success"' import_file_output.log; then
                echo "‚úÖ Found 'success' field in response"
                if grep -q '"success": true' import_file_output.log; then
                  echo "‚úÖ Success is true"
                else
                  echo "‚ö†Ô∏è  Success is not true"
                fi
              else
                echo "‚ö†Ô∏è  'success' field not found in response"
              fi
          
              if grep -q '"total_rows"' import_file_output.log; then
                echo "‚úÖ Found 'total_rows' field in response"
              else
                echo "‚ö†Ô∏è  'total_rows' field not found in response"
              fi
            else
              echo "‚ùå Import-file HTTPie request failed with exit code: $IMPORT_FILE_EXIT_CODE"
              echo "=== HTTPie Error Details ==="
              cat import_file_output.log
              echo "=== End HTTPie Error Details ==="
              echo "=== Current application log (last 20 lines) ==="
              tail -20 output.log
              echo "=== End application log ==="
          
              # Check if it's the known HTTPie syntax issue
              if grep -q "Request body.*and request data.*cannot be mixed" import_file_output.log; then
                echo "üîç HTTPie syntax error detected - mixing body and key=value data"
                echo "üí° This suggests the HTTPie command syntax needs to be adjusted"
              fi
          
              # Mark test as failed but continue
              TEST_FAILURES=$((TEST_FAILURES + 1))
            fi
          
            # Request 2 - Import CSV with inline data (with --ignore-stdin fix)
            echo "=== Making second request (import-data) ==="
          
            echo "Executing: http --ignore-stdin POST :8081 method=POST url=/import-csv 'body[csv_data]=\"\$(cat security_events.csv)\"'"
          
            # Capture both stdout and stderr, and get exit code
            set +e
            http --ignore-stdin POST :8081 method=POST url=/import-csv 'body[csv_data]="$(cat security_events.csv)"' > import_data_output.log 2>&1
            IMPORT_DATA_EXIT_CODE=$?
            set -e
          
            echo "Import-data exit code: $IMPORT_DATA_EXIT_CODE"
            echo "Import-data full output:"
            cat import_data_output.log
          
            if [ $IMPORT_DATA_EXIT_CODE -eq 0 ]; then
              echo "‚úÖ Import-data HTTPie request executed successfully"
          
              # Verify response structure
              if grep -q '"success": true' import_data_output.log; then
                echo "‚úÖ Success flag is true in import-data response"
              else
                echo "‚ö†Ô∏è  Success flag not true in import-data response"
              fi
          
              if grep -q '"processed_rows"' import_data_output.log; then
                echo "‚úÖ Found 'processed_rows' field in response"
              else
                echo "‚ö†Ô∏è  'processed_rows' field not found in response"
              fi
            else
              echo "‚ùå Import-data HTTPie request failed with exit code: $IMPORT_DATA_EXIT_CODE"
              echo "=== HTTPie Error Details ==="
              cat import_data_output.log
              echo "=== End HTTPie Error Details ==="
          
              # Check if it's the known HTTPie syntax issue
              if grep -q "Request body.*and request data.*cannot be mixed" import_data_output.log; then
                echo "üîç HTTPie syntax error detected - mixing body and key=value data"
                echo "üí° This suggests the HTTPie command syntax needs to be adjusted"
              fi
          
              # Mark test as failed but continue
              TEST_FAILURES=$((TEST_FAILURES + 1))
            fi
          
            # Request 3 - Execute import.py script (only if it exists)
            if [ -f "import.py" ]; then
              echo "=== Running third test (executing import.py script) ==="
          
              set +e
              python import.py > import_script_output.log 2>&1
              IMPORT_SCRIPT_EXIT_CODE=$?
              set -e
          
              echo "Import script exit code: $IMPORT_SCRIPT_EXIT_CODE"
              echo "Import script output:"
              cat import_script_output.log
          
              if [ $IMPORT_SCRIPT_EXIT_CODE -eq 0 ]; then
                echo "‚úÖ import.py executed successfully"
          
                # Check for expected response fields
                if grep -q '"success"' import_script_output.log; then
                  echo "‚úÖ Found 'success' field in import.py output"
                else
                  echo "‚ö†Ô∏è  'success' field not found in import.py output"
                fi
              else
                echo "‚ùå import.py failed with exit code: $IMPORT_SCRIPT_EXIT_CODE"
                echo "=== Import Script Error Details ==="
                cat import_script_output.log
                echo "=== End Import Script Error Details ==="
                # Mark test as failed but continue
                TEST_FAILURES=$((TEST_FAILURES + 1))
              fi
            else
              echo "‚ö†Ô∏è  import.py not found in function directory, skipping script test"
            fi
          
            # Final application log check
            echo "=== Final application status ==="
            if ps -p $PID > /dev/null 2>&1; then
              echo "‚úÖ Application process still running (PID: $PID)"
            else
              echo "‚ö†Ô∏è  Application process no longer running"
            fi
          
            echo "=== Final application log (last 30 lines) ==="
            tail -30 output.log
            echo "=== End final log ==="
          fi
          
          # Clean up the process
          kill $PID 2>/dev/null || true
          
          # Exit with failure if any tests failed
          if [ $TEST_FAILURES -gt 0 ]; then
            echo "‚ùå $TEST_FAILURES test(s) failed"
            exit 1
          else
            echo "‚úÖ All tests passed"
          fi
        working-directory: ${{ matrix.function }}

  test-ui:
    name: Build and Test UI
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 22
      - name: Install dependencies
        run: npm ci
        working-directory: ui/extensions/user-preferences
      - name: Build React app
        run: npm run build
        working-directory: ui/extensions/user-preferences
      - name: Test React app
        run: npm run test:ci
        working-directory: ui/extensions/user-preferences
